#!/bin/bash

set -eu -o pipefail

ssh_user_host=postgres@localhost
db_user=machine_manager
db_name=machine_manager
backup_file=~/.config/machine_manager/backup.sql

make_backup() {
	# Make the backup folder if it doesn't already exist
	mkdir -p "$(dirname "$backup_file")"
	# Rotate existing backups
	mv "$backup_file.2" "$backup_file.3" 2> /dev/null || true
	mv "$backup_file.1" "$backup_file.2" 2> /dev/null || true
	mv "$backup_file"   "$backup_file.1" 2> /dev/null || true

	# For the backup, create a table with a subset of the machines table, containing
	# just the columns with data that can't be probed.  This way, after a big schema
	# change, we still typically will not need to edit backup.sql for the restore.
	create_backup_subset="\
	DROP TABLE IF EXISTS machines__backup;
	CREATE TABLE         machines__backup AS SELECT
	                         hostname, wireguard_ip, wireguard_privkey, wireguard_pubkey,
	                         wireguard_port, ssh_port, added_time, country, release, boot,
	                         host_machine, ssh_port_on_host_machine, wireguard_port_on_host_machine
	                     FROM machines;

	DROP TABLE IF EXISTS machine_tags__backup;
	CREATE TABLE         machine_tags__backup AS SELECT * FROM machine_tags;

	DROP TABLE IF EXISTS networks__backup;
	CREATE TABLE         networks__backup AS SELECT * FROM networks;

	DROP TABLE IF EXISTS machine_addresses__backup;
	CREATE TABLE         machine_addresses__backup AS SELECT * FROM machine_addresses;
	"
	echo "$create_backup_subset" | ssh "$ssh_user_host" "psql -v ON_ERROR_STOP=1 -d $db_name"

	# Create the backup file
	ssh "$ssh_user_host" "\
		pg_dump \
			--data-only \
			--table machines__backup \
			--table machine_tags__backup \
			--table networks__backup \
			--table machine_addresses__backup \
			machine_manager
		" > "$backup_file"
	# Fix the backup to restore into the correct tables
	sed -i -r 's,^COPY machines__backup ,COPY machines ,'                   "$backup_file"
	sed -i -r 's,^COPY machine_tags__backup ,COPY machine_tags ,'           "$backup_file"
	sed -i -r 's,^COPY networks__backup ,COPY networks ,'                   "$backup_file"
	sed -i -r 's,^COPY machine_addresses__backup ,COPY machine_addresses ,' "$backup_file"
}

if [[ "${1:-}" != "--use-existing-backup" ]]; then
	make_backup
fi

# Drop database, create database, import schema and backup
reset_db="\
DROP DATABASE IF EXISTS          $db_name;
CREATE DATABASE                  $db_name;
GRANT ALL PRIVILEGES ON DATABASE $db_name TO $db_user;
ALTER DATABASE                   $db_name SET bytea_output TO 'escape';
"
echo "$reset_db" | ssh "$ssh_user_host" "psql -v ON_ERROR_STOP=1"
cat schema.sql   | ssh "$ssh_user_host" "psql -v ON_ERROR_STOP=1 -d $db_name"
# pg_dump dumps tables in an order that violates foreign key constraints when
# restored, so use `set session_replication_role = replica;` to disable all
# triggers (including FK constraints).
(
	echo "set session_replication_role = replica;" &&
	cat "$backup_file"
) | ssh "$ssh_user_host" "psql -v ON_ERROR_STOP=1 -d $db_name"

echo "Backup restored.  You should probe all machines now."
